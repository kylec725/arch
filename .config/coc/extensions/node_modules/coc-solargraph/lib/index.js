"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const language_client_1 = require("./language-client");
const SolargraphDocumentProvider_1 = tslib_1.__importDefault(require("./SolargraphDocumentProvider"));
const solargraph = tslib_1.__importStar(require("solargraph-utils"));
const which_1 = tslib_1.__importDefault(require("which"));
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { subscriptions } = context;
        const config = coc_nvim_1.workspace.getConfiguration().get('solargraph', {});
        const enable = config.enable;
        if (enable === false)
            return;
        let command = config.commandPath || 'solargraph';
        try {
            which_1.default.sync(command);
        }
        catch (e) {
            coc_nvim_1.workspace.showMessage(`Solargraph command '${command}' not found!`, 'error');
            return;
        }
        const selector = config.filetypes || ['ruby'];
        let applyConfiguration = (config) => {
            config.commandPath = config.commandPath || 'solargraph';
            config.useBundler = config.useBundler || false;
            config.bundlerPath = config.bundlerPath || 'bundle';
            config.viewsPath = context.extensionPath + '/views';
            config.withSnippets = config.withSnippets || false;
            config.workspace = coc_nvim_1.workspace.rootPath || null;
        };
        let solargraphConfiguration = new solargraph.Configuration();
        applyConfiguration(solargraphConfiguration);
        let languageClient;
        let disposableClient;
        const startLanguageServer = () => {
            languageClient = language_client_1.makeLanguageClient(solargraphConfiguration);
            languageClient.onReady().then(() => {
                subscriptions.push(coc_nvim_1.workspace.registerTextDocumentContentProvider('solargraph', new SolargraphDocumentProvider_1.default(languageClient)));
                if (coc_nvim_1.workspace.getConfiguration('solargraph').checkGemVersion) {
                    languageClient.sendNotification('$/solargraph/checkGemVersion', { verbose: false });
                }
            }).catch(err => {
                // tslint:disable-next-line: no-console
                console.log('Error starting Solargraph socket provider', err);
                if (err.toString().includes('ENOENT') || err.toString().includes('command not found')) {
                    // tslint:disable-next-line: no-floating-promises
                    coc_nvim_1.workspace.showPrompt('Solargraph gem not found. Run `gem install solargraph` or update your Gemfile., Install Now?').then(approved => {
                        if (approved) {
                            solargraph.installGem(solargraphConfiguration).then(() => {
                                coc_nvim_1.workspace.showMessage('Successfully installed the Solargraph gem.');
                                if (disposableClient)
                                    disposableClient.dispose();
                                startLanguageServer();
                            }).catch(() => {
                                coc_nvim_1.workspace.showMessage('Failed to install the Solargraph gem.', 'error');
                            });
                        }
                    });
                }
                else {
                    coc_nvim_1.workspace.showMessage("Failed to start Solargraph: " + err, 'error');
                }
            });
            languageClient.start();
            disposableClient = coc_nvim_1.services.registLanguageClient(languageClient);
            context.subscriptions.push(disposableClient);
        };
        // Search command
        let disposableSearch = coc_nvim_1.commands.registerCommand('solargraph.search', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { nvim } = coc_nvim_1.workspace;
            let search = yield nvim.call('input', ['Search:', '']);
            nvim.command('normal! :<C-u>', true);
            if (!search)
                return;
            let uri = 'solargraph:///search?query=' + encodeURIComponent(search);
            yield coc_nvim_1.workspace.openResource(uri);
        }));
        context.subscriptions.push(disposableSearch);
        // Environment command
        let disposableEnv = coc_nvim_1.commands.registerCommand('solargraph.environment', () => {
            return coc_nvim_1.workspace.openResource('solargraph:///environment');
        });
        context.subscriptions.push(disposableEnv);
        // Check gem version command
        let disposableCheckGemVersion = coc_nvim_1.commands.registerCommand('solargraph.checkGemVersion', () => {
            if (languageClient) {
                languageClient.sendNotification('$/solargraph/checkGemVersion', { verbose: true });
            }
        });
        context.subscriptions.push(disposableCheckGemVersion);
        // Build gem documentation command
        let disposableBuildGemDocs = coc_nvim_1.commands.registerCommand('solargraph.buildGemDocs', () => {
            let prepareStatus = coc_nvim_1.workspace.createStatusBarItem(10, { progress: true });
            prepareStatus.text = 'Building new gem documentation...';
            languageClient.sendRequest('$/solargraph/documentGems', { rebuild: false }).then(response => {
                prepareStatus.dispose();
                if (response['status'] == 'ok') {
                    coc_nvim_1.workspace.showMessage('Gem documentation complete.', 'more');
                }
                else {
                    coc_nvim_1.workspace.showMessage('An error occurred building gem documentation.', 'error');
                    // tslint:disable-next-line: no-console
                    console.log(response);
                }
            });
        });
        context.subscriptions.push(disposableBuildGemDocs);
        // Rebuild gems documentation command
        let disposableRebuildAllGemDocs = coc_nvim_1.commands.registerCommand('solargraph.rebuildAllGemDocs', () => {
            let prepareStatus = coc_nvim_1.workspace.createStatusBarItem(10, { progress: true });
            prepareStatus.text = 'Rebuilding all gem documentation...';
            languageClient.sendRequest('$/solargraph/documentGems', { rebuild: true }).then(response => {
                prepareStatus.dispose();
                if (response['status'] == 'ok') {
                    coc_nvim_1.workspace.showMessage('Gem documentation complete.', 'more');
                }
                else {
                    coc_nvim_1.workspace.showMessage('An error occurred rebuilding gem documentation.', 'error');
                    // tslint:disable-next-line: no-console
                    console.log(response);
                }
            });
        });
        context.subscriptions.push(disposableRebuildAllGemDocs);
        // Solargraph configuration command
        let disposableSolargraphConfig = coc_nvim_1.commands.registerCommand('solargraph.config', () => {
            let child = solargraph.commands.solargraphCommand(['config'], solargraphConfiguration);
            child.on('exit', code => {
                if (code == 0) {
                    coc_nvim_1.workspace.showMessage('Created default .solargraph.yml file.');
                }
                else {
                    coc_nvim_1.workspace.showMessage('Error creating .solargraph.yml file.', 'error');
                }
            });
        });
        context.subscriptions.push(disposableSolargraphConfig);
        // Solargraph download core command
        let disposableSolargraphDownloadCore = coc_nvim_1.commands.registerCommand('solargraph.downloadCore', () => {
            if (languageClient) {
                languageClient.sendNotification('$/solargraph/downloadCore');
            }
            else {
                coc_nvim_1.workspace.showMessage('Solargraph is still starting. Please try again in a moment.');
            }
        });
        startLanguageServer();
    });
}
exports.activate = activate;
//# sourceMappingURL=index.js.map