"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const api_1 = tslib_1.__importDefault(require("../utils/api"));
const async_1 = require("../utils/async");
const typeConverters = tslib_1.__importStar(require("../utils/typeConverters"));
const languageModeIds = tslib_1.__importStar(require("../utils/languageModeIds"));
function mode2ScriptKind(mode) {
    switch (mode) {
        case languageModeIds.typescript:
            return 'TS';
        case languageModeIds.typescripttsx:
            return 'TSX';
        case languageModeIds.typescriptjsx:
            return 'TSX';
        case languageModeIds.typescriptreact:
            return 'TSX';
        case languageModeIds.javascript:
            return 'JS';
        case languageModeIds.javascriptreact:
            return 'JSX';
    }
    return undefined;
}
/**
 * Manages synchronization of buffers with the TS server.
 *
 * If supported, batches together file changes. This allows the TS server to more efficiently process changes.
 */
class BufferSynchronizer {
    constructor(client) {
        this.client = client;
        this._pending = {};
        this._pendingFiles = new Set();
    }
    open(args) {
        if (this.supportsBatching) {
            this.updatePending(args.file, pending => {
                if (!pending.openFiles) {
                    pending.openFiles = [];
                }
                pending.openFiles.push(args);
            });
        }
        else {
            this.client.executeWithoutWaitingForResponse('open', args);
        }
    }
    close(filepath) {
        if (this.supportsBatching) {
            this.updatePending(filepath, pending => {
                if (!pending.closedFiles) {
                    pending.closedFiles = [];
                }
                pending.closedFiles.push(filepath);
            });
        }
        else {
            const args = { file: filepath };
            this.client.executeWithoutWaitingForResponse('close', args);
        }
    }
    change(filepath, events) {
        if (!events.length) {
            return;
        }
        if (this.supportsBatching) {
            this.updatePending(filepath, pending => {
                if (!pending.changedFiles) {
                    pending.changedFiles = [];
                }
                pending.changedFiles.push({
                    fileName: filepath,
                    textChanges: events.map((change) => ({
                        newText: change.text,
                        start: typeConverters.Position.toLocation(change.range.start),
                        end: typeConverters.Position.toLocation(change.range.end),
                    })).reverse(),
                });
            });
        }
        else {
            for (const { range, text } of events) {
                const args = Object.assign({ insertString: text }, typeConverters.Range.toFormattingRequestArgs(filepath, range));
                this.client.executeWithoutWaitingForResponse('change', args);
            }
        }
    }
    beforeCommand(command) {
        if (command === 'updateOpen') {
            return;
        }
        this.flush();
    }
    flush() {
        if (!this.supportsBatching) {
            // We've already eagerly synchronized
            return;
        }
        if (this._pending.changedFiles || this._pending.closedFiles || this._pending.openFiles) {
            this.client.executeWithoutWaitingForResponse('updateOpen', this._pending);
            this._pending = {};
            this._pendingFiles.clear();
        }
    }
    get supportsBatching() {
        return this.client.apiVersion.gte(api_1.default.v340) && coc_nvim_1.workspace.getConfiguration('typescript').get('useBatchedBufferSync', true);
    }
    updatePending(filepath, f) {
        if (this.supportsBatching && this._pendingFiles.has(filepath)) {
            this.flush();
            this._pendingFiles.clear();
            f(this._pending);
            this._pendingFiles.add(filepath);
        }
        else {
            f(this._pending);
        }
    }
}
class BufferSyncSupport {
    constructor(client) {
        this.uris = new Set();
        this.disposables = [];
        this.pendingDiagnostics = new Map();
        this._validateJavaScript = true;
        this._validateTypeScript = true;
        this.listening = false;
        this._onDelete = new vscode_languageserver_protocol_1.Emitter();
        this.onDelete = this._onDelete.event;
        this.client = client;
        this.synchronizer = new BufferSynchronizer(client);
        this.modeIds = new Set(languageModeIds.languageIds);
        this.diagnosticDelayer = new async_1.Delayer(300);
    }
    listen() {
        if (this.listening) {
            return;
        }
        this.listening = true;
        coc_nvim_1.workspace.onDidOpenTextDocument(this.onDidOpenTextDocument, this, this.disposables);
        coc_nvim_1.workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, this.disposables);
        coc_nvim_1.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, this.disposables);
        coc_nvim_1.workspace.textDocuments.forEach(this.onDidOpenTextDocument, this);
        this.updateConfiguration();
        coc_nvim_1.workspace.onDidChangeConfiguration(this.updateConfiguration, this, this.disposables);
    }
    dispose() {
        this.pendingDiagnostics.clear();
        coc_nvim_1.disposeAll(this.disposables);
    }
    onDidOpenTextDocument(document) {
        if (!this.modeIds.has(document.languageId))
            return;
        let { uri } = document;
        let filepath = this.client.toPath(uri);
        this.uris.add(uri);
        const args = {
            file: filepath,
            fileContent: document.getText()
        };
        if (this.client.apiVersion.gte(api_1.default.v203)) {
            const scriptKind = mode2ScriptKind(document.languageId);
            if (scriptKind) {
                args.scriptKindName = scriptKind;
            }
        }
        if (this.client.apiVersion.gte(api_1.default.v230)) {
            let root = this.client.getProjectRootPath(document.uri);
            if (root)
                args.projectRootPath = root;
        }
        this.synchronizer.open(args);
        // this.client.executeWithoutWaitingForResponse('open', args)
        this.requestDiagnostic(uri);
    }
    onDidCloseTextDocument(document) {
        let { uri } = document;
        if (!this.uris.has(uri))
            return;
        let filepath = this.client.toPath(uri);
        this.uris.delete(uri);
        this.pendingDiagnostics.delete(uri);
        this.synchronizer.close(filepath);
        this._onDelete.fire(uri);
        this.requestAllDiagnostics();
        // this.client.executeWithoutWaitingForResponse('close', args)
    }
    onDidChangeTextDocument(e) {
        let { textDocument, contentChanges } = e;
        let { uri } = textDocument;
        if (!this.uris.has(uri))
            return;
        let filepath = this.client.toPath(uri);
        this.synchronizer.change(filepath, contentChanges);
        const didTrigger = this.requestDiagnostic(uri);
        if (!didTrigger && this.pendingGetErr) {
            // In this case we always want to re-trigger all diagnostics
            this.pendingGetErr.cancel();
            this.pendingGetErr = undefined;
            this.triggerDiagnostics();
        }
    }
    beforeCommand(command) {
        this.synchronizer.beforeCommand(command);
    }
    interuptGetErr(f) {
        if (!this.pendingGetErr) {
            return f();
        }
        this.pendingGetErr.cancel();
        this.pendingGetErr = undefined;
        const result = f();
        this.triggerDiagnostics();
        return result;
    }
    getErr(resources) {
        const handledResources = resources.filter(resource => this.uris.has(resource.toString()));
        if (!handledResources.length) {
            return;
        }
        for (const resource of handledResources) {
            let uri = resource.toString();
            if (this.shouldValidate(uri)) {
                this.pendingDiagnostics.set(uri, Date.now());
            }
        }
        this.triggerDiagnostics();
    }
    triggerDiagnostics(delay = 200) {
        this.diagnosticDelayer.trigger(() => {
            this.sendPendingDiagnostics();
        }, delay);
    }
    requestAllDiagnostics() {
        for (const uri of this.uris) {
            if (this.shouldValidate(uri)) {
                this.pendingDiagnostics.set(uri, Date.now());
            }
        }
        this.diagnosticDelayer.trigger(() => {
            this.sendPendingDiagnostics();
        }, 200);
    }
    requestDiagnostic(uri) {
        let document = coc_nvim_1.workspace.getDocument(uri);
        if (!document || !this.shouldValidate(uri))
            return false;
        this.pendingDiagnostics.set(uri, Date.now());
        const lineCount = document.lineCount;
        const delay = Math.min(Math.max(Math.ceil(lineCount / 20), 300), 800);
        this.triggerDiagnostics(delay);
        return true;
    }
    hasPendingDiagnostics(uri) {
        return this.pendingDiagnostics.has(uri);
    }
    sendPendingDiagnostics() {
        const uris = Array.from(this.pendingDiagnostics.entries())
            .sort((a, b) => a[1] - b[1])
            .map(entry => entry[0]);
        // Add all open TS buffers to the geterr request. They might be visible
        for (const uri of this.uris) {
            if (uris.indexOf(uri) == -1) {
                uris.push(uri);
            }
        }
        let files = uris.map(uri => this.client.toPath(uri));
        if (files.length) {
            if (this.pendingGetErr)
                this.pendingGetErr.cancel();
            const getErr = this.pendingGetErr = GetErrRequest.executeGetErrRequest(this.client, files, () => {
                if (this.pendingGetErr === getErr) {
                    this.pendingGetErr = undefined;
                }
            });
        }
        this.pendingDiagnostics.clear();
    }
    updateConfiguration() {
        const jsConfig = coc_nvim_1.workspace.getConfiguration('javascript', null);
        const tsConfig = coc_nvim_1.workspace.getConfiguration('typescript', null);
        this._validateJavaScript = jsConfig.get('validate.enable', true);
        this._validateTypeScript = tsConfig.get('validate.enable', true);
    }
    shouldValidate(uri) {
        let doc = coc_nvim_1.workspace.getDocument(uri);
        if (!doc)
            return false;
        if (languageModeIds.languageIds.indexOf(doc.filetype) == -1) {
            return false;
        }
        if (doc.filetype.startsWith('javascript')) {
            return this._validateJavaScript;
        }
        return this._validateTypeScript;
    }
}
exports.default = BufferSyncSupport;
class GetErrRequest {
    constructor(client, files, _token, onDone) {
        this.files = files;
        this._token = _token;
        this._done = false;
        const args = {
            delay: 0,
            files: this.files
        };
        const done = () => {
            if (this._done) {
                return;
            }
            this._done = true;
            onDone();
        };
        client.executeAsync('geterr', args, _token.token).then(done, done);
    }
    static executeGetErrRequest(client, files, onDone) {
        const token = new vscode_languageserver_protocol_1.CancellationTokenSource();
        return new GetErrRequest(client, files, token, onDone);
    }
    cancel() {
        if (!this._done) {
            this._token.cancel();
        }
        this._token.dispose();
    }
}
//# sourceMappingURL=bufferSyncSupport.js.map