"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const safe_1 = tslib_1.__importDefault(require("colors/safe"));
class YankList extends coc_nvim_1.BasicList {
    constructor(nvim, db) {
        super(nvim);
        this.db = db;
        this.name = 'yank';
        this.description = 'list of yank history';
        this.defaultAction = 'append';
        this.addAction('append', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { document, position } = yield coc_nvim_1.workspace.getCurrentState();
            let doc = coc_nvim_1.workspace.getDocument(document.uri);
            let edits = [];
            let { regtype, content } = item.data;
            let line = doc.getline(position.line);
            if (regtype == 'v') {
                let pos = vscode_languageserver_protocol_1.Position.create(position.line, Math.min(position.character + 1, line.length));
                edits.push({
                    range: vscode_languageserver_protocol_1.Range.create(pos, pos),
                    newText: content.join('\n')
                });
            }
            else if (regtype == 'V') {
                let pos = vscode_languageserver_protocol_1.Position.create(position.line + 1, 0);
                edits.push({
                    range: vscode_languageserver_protocol_1.Range.create(pos, pos),
                    newText: content.join('\n') + '\n'
                });
            }
            else {
                let col = yield nvim.call('col', ['.']);
                for (let i = position.line; i < position.line + content.length; i++) {
                    let line = doc.getline(i);
                    let character = byteSlice(line, 0, col + 1).length;
                    let pos = vscode_languageserver_protocol_1.Position.create(i, character);
                    edits.push({
                        range: vscode_languageserver_protocol_1.Range.create(pos, pos),
                        newText: content[i - position.line]
                    });
                }
            }
            console.log(JSON.stringify(edits, null, 2));
            yield doc.applyEdits(nvim, edits);
        }));
        this.addAction('prepend', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { document, position } = yield coc_nvim_1.workspace.getCurrentState();
            let doc = coc_nvim_1.workspace.getDocument(document.uri);
            let edits = [];
            let { regtype, content } = item.data;
            if (regtype == 'v') {
                let pos = vscode_languageserver_protocol_1.Position.create(position.line, position.character);
                edits.push({
                    range: vscode_languageserver_protocol_1.Range.create(pos, pos),
                    newText: content.join('\n')
                });
            }
            else if (regtype == 'V') {
                let pos = vscode_languageserver_protocol_1.Position.create(position.line, 0);
                edits.push({
                    range: vscode_languageserver_protocol_1.Range.create(pos, pos),
                    newText: content.join('\n') + '\n'
                });
            }
            else {
                let col = yield nvim.call('col', ['.']);
                for (let i = position.line; i < position.line + content.length; i++) {
                    let line = doc.getline(i);
                    let character = byteSlice(line, 0, col).length;
                    let pos = vscode_languageserver_protocol_1.Position.create(i, character);
                    edits.push({
                        range: vscode_languageserver_protocol_1.Range.create(pos, pos),
                        newText: content[i - position.line]
                    });
                }
            }
            yield doc.applyEdits(nvim, edits);
        }));
        this.addAction('open', (item) => {
            let content = item.data.path;
            let parts = content.split('\t');
            let position = vscode_languageserver_protocol_1.Position.create(Number(parts[1]) - 1, Number(parts[2]) - 1);
            coc_nvim_1.workspace.jumpTo(parts[0], position);
        });
        this.addAction('yank', (item) => {
            let content = item.data.content;
            content = content.map(s => s.replace(/\\/g, '\\\\').replace(/"/, '\\"'));
            nvim.command(`let @" = "${content.join('\\n')}"`, true);
        });
        this.addAction('delete', (item) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { id } = item.data;
            yield this.db.delete(id);
        }), { persist: true, reload: true });
        this.addAction('preview', (item, context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let { filetype, content } = item.data;
            let mod = context.options.position == 'top' ? 'below' : '';
            let height = content.length;
            let winid = context.listWindow.id;
            nvim.pauseNotification();
            nvim.command('pclose', true);
            nvim.command(`${mod} ${height}new +setl\\ previewwindow`, true);
            nvim.command('setl buftype=nofile', true);
            nvim.command('setl bufhidden=wipe', true);
            nvim.command(`setl filetype=${filetype}`, true);
            nvim.call('setline', [1, content[0]], true);
            nvim.call('append', [1, content.slice(1)], true);
            nvim.command('normal! ggzt', true);
            nvim.call('win_gotoid', [winid], true);
            nvim.command('redraw', true);
            yield nvim.resumeNotification();
        }));
    }
    loadItems(_context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let arr = yield this.db.load();
            let columns = yield this.nvim.getOption('columns');
            let res = [];
            for (let item of arr) {
                let regtype;
                if (item.regtype == 'v') {
                    regtype = 'char ';
                }
                else if (item.regtype == 'V') {
                    regtype = 'line ';
                }
                else {
                    regtype = 'block';
                }
                let text = item.content.join(' ');
                let abbr = text.length > columns - 15 ? text.slice(0, columns - 15) + safe_1.default.grey('...') : text;
                res.push({
                    label: `${safe_1.default.yellow(regtype)} ${abbr}`,
                    filterText: abbr,
                    data: Object.assign({}, item)
                });
            }
            return res;
        });
    }
}
exports.default = YankList;
function byteSlice(content, start, end) {
    let buf = Buffer.from(content, 'utf8');
    return buf.slice(start, end).toString('utf8');
}
//# sourceMappingURL=yank.js.map