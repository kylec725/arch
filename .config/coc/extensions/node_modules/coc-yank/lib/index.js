"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const coc_nvim_1 = require("coc.nvim");
const util_1 = require("./util");
const yank_1 = tslib_1.__importDefault(require("./list/yank"));
const db_1 = tslib_1.__importDefault(require("./db"));
const START_ID = 2080;
function activate(context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let { subscriptions, storagePath } = context;
        let stat = yield util_1.statAsync(storagePath);
        if (!stat || !stat.isDirectory()) {
            yield util_1.mkdirAsync(storagePath);
        }
        const config = coc_nvim_1.workspace.getConfiguration('yank');
        let db = new db_1.default(storagePath, config.get('list.maxsize', 200));
        if (config.get('highlight.enable', true)) {
            coc_nvim_1.workspace.nvim.command('highlight default link HighlightedyankRegion IncSearch', true);
        }
        let srcId = START_ID;
        let winid;
        let curr_ids = [];
        coc_nvim_1.workspace.registerAutocmd({
            event: 'WinLeave',
            arglist: ['win_getid()'],
            request: true,
            callback: (wid) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (wid != winid)
                    return;
                if (curr_ids.length) {
                    yield coc_nvim_1.workspace.nvim.call('coc#util#clearmatches', [curr_ids]);
                    curr_ids = [];
                }
            })
        });
        subscriptions.push(coc_nvim_1.listManager.registerList(new yank_1.default(coc_nvim_1.workspace.nvim, db)));
        subscriptions.push(coc_nvim_1.workspace.registerAutocmd({
            event: 'TextYankPost',
            arglist: ['v:event', "+expand('<abuf>')"],
            callback: (event, bufnr) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                let { nvim } = coc_nvim_1.workspace;
                let { regtype, operator, regcontents } = event;
                if (operator != 'y')
                    return;
                winid = yield nvim.call('win_getid');
                let enable = config.get('highlight.enable', true);
                let doc = coc_nvim_1.workspace.getDocument(bufnr);
                if (!doc)
                    return;
                let [, lnum, col] = yield nvim.call('getpos', ["'["]);
                if (enable) {
                    let ids = [];
                    let ranges = [];
                    let duration = config.get('highlight.duration', 500);
                    // block selection
                    if (regtype.startsWith('\x16')) {
                        let view = yield nvim.call('winsaveview');
                        yield nvim.call('setpos', ['.', [0, lnum, col, 0]]);
                        for (let i = lnum; i < lnum + regcontents.length; i++) {
                            let col = yield nvim.call('col', ['.']);
                            ranges.push([i, col, Number(regtype[1])]);
                            yield nvim.command('normal! j');
                        }
                        yield nvim.call('winrestview', [view]);
                    }
                    else if (regtype == 'v') {
                        for (let i = lnum; i < lnum + regcontents.length; i++) {
                            if (i == lnum) {
                                ranges.push([i, col, Buffer.byteLength(regcontents[0])]);
                            }
                            else {
                                ranges.push([i, 1, Buffer.byteLength(regcontents[i - lnum])]);
                            }
                        }
                    }
                    else if (regtype == 'V') {
                        for (let i = lnum; i < lnum + regcontents.length; i++) {
                            ranges.push([i]);
                        }
                    }
                    else {
                        return;
                    }
                    nvim.pauseNotification();
                    for (let list of util_1.group(ranges, 8)) {
                        nvim.call('matchaddpos', ['HighlightedyankRegion', list, 99, srcId], true);
                        ids.push(srcId);
                        srcId = srcId + 1;
                    }
                    yield nvim.resumeNotification();
                    if (ids.length) {
                        curr_ids.push(...ids);
                        setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                            yield nvim.call('coc#util#clearmatches', [ids]);
                            srcId = START_ID;
                        }), duration);
                    }
                }
                let path = `${doc.uri}\t${lnum}\t${col}`;
                regtype = regtype.startsWith('\x16') ? '^v' : regtype;
                yield db.add(regcontents, regtype, path, doc.filetype);
            })
        }));
    });
}
exports.activate = activate;
//# sourceMappingURL=index.js.map